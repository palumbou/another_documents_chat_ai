<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Documents Chat AI</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="app-container">
    <!-- Left Sidebar -->
    <aside class="sidebar">
      <header class="sidebar-header">
        <div class="header-content">
          <h1>Documents Chat AI</h1>
          <button id="theme-toggle" class="theme-toggle" title="Switch between Dawn and Moon themes">
            <span class="theme-icon">üåô</span>
          </button>
        </div>
      </header>
      
      <!-- Documents Management -->
      <section class="documents-section">
        <h3>Documents</h3>
        <div id="existing-docs">
          <div id="docs-list">Loading documents...</div>
        </div>
        <div class="upload-area">
          <form id="upload-form" action="/upload" method="post" enctype="multipart/form-data">
            <input type="file"
                   name="files"
                   id="file-input"
                   multiple
                   accept=".pdf,.docx,.txt"
                   class="file-input">
            <button type="submit" class="btn-primary">Upload Files</button>
          </form>
          <div id="upload-msg" class="status-msg"></div>
        </div>
      </section>

      <!-- Models Management -->
      <section class="models-section">
        <h3>Models</h3>
        <div class="model-group">
          <label for="remote-select">Available Models:</label>
          <select id="remote-select"></select>
          <button id="pull-btn" class="btn-secondary">Download</button>
          <span id="pull-msg" class="status-msg"></span>
        </div>
        <div class="model-group">
          <label for="local-select">Active Model:</label>
          <select id="local-select"></select>
          <button id="run-btn" class="btn-primary">Use</button>
          <span id="run-msg" class="status-msg"></span>
        </div>
      </section>

      <!-- System Status -->
      <section class="status-section">
        <h3>System Status</h3>
        <div id="status">
          <div class="status-item">
            <span class="status-label">Ollama:</span>
            <span id="conn-status">Checking‚Ä¶</span>
          </div>
          <div class="status-item">
            <span class="status-label">Engine:</span>
            <span id="engine-info">Loading‚Ä¶</span>
          </div>
          <div class="status-item">
            <span class="status-label">Memory:</span>
            <span id="memory-info">Checking‚Ä¶</span>
          </div>
        </div>
      </section>
    </aside>

    <!-- Main Chat Area -->
    <main class="chat-container">
      <div class="chat-messages" id="chat-messages">
        <div class="welcome-message">
          <h2>ü§ñ Welcome to Documents Chat AI</h2>
          <p>Your intelligent document assistant powered by Ollama</p>
          <div class="welcome-features">
            <div class="feature-grid">
              <div class="feature-item">
                <span class="feature-icon">üìÅ</span>
                <span>Upload PDFs, DOCX, TXT files</span>
              </div>
              <div class="feature-item">
                <span class="feature-icon">üîç</span>
                <span>Advanced OCR for scanned documents</span>
              </div>
              <div class="feature-item">
                <span class="feature-icon">üß†</span>
                <span>Intelligent document analysis</span>
              </div>
              <div class="feature-item">
                <span class="feature-icon">üí¨</span>
                <span>Context-aware AI responses</span>
              </div>
            </div>
          </div>
          <div class="welcome-actions">
            <p><strong>Get started:</strong></p>
            <ol>
              <li>Upload documents using the sidebar</li>
              <li>Ask questions about your documents</li>
              <li>Or just chat with the AI without documents!</li>
            </ol>
            <div class="theme-info">
              <p>üí° <em>Try switching between Ros√© Pine Dawn ‚òÄÔ∏è and Moon üåô themes using the button above!</em></p>
            </div>
          </div>
        </div>
      </div>
      
      <div class="chat-input-area">
        <div class="input-container">
          <textarea id="chat-input" 
                    placeholder="Ask a question about your documents... (Enter to send, Shift+Enter for new line)"
                    rows="3"></textarea>
          <button id="send-btn" class="btn-send" title="Send message (Enter)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="22" y1="2" x2="11" y2="13"></line>
              <polygon points="22,2 15,22 11,13 2,9"></polygon>
            </svg>
          </button>
        </div>
        <div class="input-help">
          <small>Press <kbd>Enter</kbd> to send, <kbd>Shift+Enter</kbd> for new line</small>
        </div>
      </div>
    </main>
  </div>

  <script>
    // 1) Check Ollama status
    async function checkStatus() {
      try {
        const res = await fetch('/status');
        const {connected, engine} = await res.json();
        document.getElementById('conn-status').innerText =
          connected ? 'üü¢ Ollama online' : 'üî¥ Ollama offline';
        
        // Handle engine object properly
        let engineText = '';
        if (connected && engine && engine.name) {
          let status = '';
          if (engine.verified) {
            status = '‚úÖ';
          } else if (engine.available) {
            status = '‚è≥';
          } else {
            status = '‚ùå';
          }
          engineText = `(Engine: ${engine.name} ${status})`;
        }
        document.getElementById('engine-info').innerText = engineText;
      } catch {
        document.getElementById('conn-status').innerText = 'üî¥ Error';
      }
    }
    checkStatus();
    setInterval(checkStatus, 15000);

    // Check system memory
    async function checkMemory() {
      try {
        const res = await fetch('/system/memory');
        const memory = await res.json();
        const memoryText = `üíæ RAM: ${memory.used_gb}/${memory.total_gb}GB (${memory.percent_used.toFixed(1)}%)`;
        document.getElementById('memory-info').innerText = memoryText;
      } catch {
        document.getElementById('memory-info').innerText = 'üíæ Memory: Error';
      }
    }
    checkMemory();
    setInterval(checkMemory, 30000);

    // Load and display existing documents with processing status
    async function loadExistingDocuments() {
      try {
        const res = await fetch('/documents');
        const data = await res.json();
        const docsList = document.getElementById('docs-list');
        
        if (data.documents && data.documents.length > 0) {
          let html = '';
          
          data.documents.forEach(doc => {
            const info = data.document_info[doc] || {};
            const status = info.processing_status || 'completed';
            const progress = info.processing_progress || 100;
            const isProcessed = info.is_processed || false;
            const chunks = info.total_chunks || 0;
            const chars = info.total_chars || 0;
            const error = info.error;
            
            // Status icon and text
            let statusIcon = '';
            let statusText = '';
            let statusClass = '';
            
            switch (status) {
              case 'pending':
                statusIcon = '‚è≥';
                statusText = 'Waiting to process...';
                statusClass = 'status-pending';
                break;
              case 'processing':
                statusIcon = 'üîÑ';
                statusText = `Processing... ${progress}%`;
                statusClass = 'status-processing';
                break;
              case 'completed':
                statusIcon = '‚úÖ';
                statusText = isProcessed ? `Ready (${chunks} chunks, ${(chars/1000).toFixed(1)}k chars)` : 'Uploaded';
                statusClass = 'status-completed';
                break;
              case 'error':
                statusIcon = '‚ùå';
                statusText = `Error: ${error || 'Processing failed'}`;
                statusClass = 'status-error';
                break;
            }
            
            html += `
              <div class="doc-item ${statusClass}">
                <div class="doc-header">
                  <span class="doc-name" title="${doc}">${doc.length > 20 ? doc.substring(0, 20) + '...' : doc}</span>
                  <span class="status-icon">${statusIcon}</span>
                </div>
                <div class="doc-info">
                  <span class="status-text">${statusText}</span>
                  ${status === 'processing' ? `<div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>` : ''}
                </div>
                <div class="doc-actions">
                  ${isProcessed ? `<button class="btn-xs" onclick="viewDocumentChunks('${doc}')" title="View Chunks">üìä</button>` : ''}
                  <button class="btn-xs delete" onclick="deleteDocument('${doc}')" title="Delete">üóëÔ∏è</button>
                  ${status === 'error' ? `<button class="btn-xs retry" onclick="retryProcessing('${doc}')" title="Retry">üîÑ</button>` : ''}
                </div>
              </div>`;
          });
          
          // Summary with processing info
          const summary = data.processing_summary || {};
          let summaryText = `Total: ${data.total_chunks} chunks across ${data.documents.length} documents`;
          if (summary.processing > 0 || summary.pending > 0) {
            summaryText += ` (${summary.pending} pending, ${summary.processing} processing)`;
          }
          
          html += `<div class="doc-summary">${summaryText}</div>`;
          docsList.innerHTML = html;
        } else {
          docsList.innerHTML = '<em>No documents uploaded yet</em>';
        }
      } catch (error) {
        document.getElementById('docs-list').innerHTML = '<em>Error loading documents</em>';
        console.error('Error loading documents:', error);
      }
    }

    // View chunks for a specific document
    async function viewDocumentChunks(filename) {
      try {
        const res = await fetch(`/documents/${encodeURIComponent(filename)}/chunks`);
        const data = await res.json();
        
        let html = `<h4>Chunks for "${filename}"</h4>`;
        html += `<p>Total chunks: ${data.total_chunks}</p>`;
        
        data.chunks.forEach((chunk, index) => {
          html += `
            <div class="chunk-item">
              <div class="chunk-header">
                <strong>Chunk ${chunk.chunk_index}/${data.total_chunks}</strong>
                <span class="chunk-size">(${chunk.char_count} characters)</span>
              </div>
              <div class="chunk-preview">${chunk.preview}</div>
            </div>`;
        });
        
        // Create modal or update a section to show chunks
        const modal = document.createElement('div');
        modal.className = 'chunks-modal';
        modal.innerHTML = `
          <div class="chunks-modal-content">
            <span class="chunks-modal-close" onclick="this.parentElement.parentElement.remove()">&times;</span>
            ${html}
          </div>`;
        
        // Add ESC key listener to close modal
        const handleEscKey = (event) => {
          if (event.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', handleEscKey);
          }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // Add click outside to close modal
        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            modal.remove();
            document.removeEventListener('keydown', handleEscKey);
          }
        });
        
        document.body.appendChild(modal);
        
      } catch (error) {
        alert(`Error loading chunks: ${error.message}`);
      }
    }

    // Delete a document
    async function deleteDocument(filename) {
      if (!confirm(`Are you sure you want to delete "${filename}"?`)) {
        return;
      }
      
      try {
        const res = await fetch(`/documents/${encodeURIComponent(filename)}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        await loadExistingDocuments(); // Refresh the list
        document.getElementById('upload-msg').innerText = `Deleted "${filename}"`;
        setTimeout(() => {
          document.getElementById('upload-msg').innerText = '';
        }, 3000);
      } catch (error) {
        alert(`Error deleting document: ${error.message}`);
      }
    }

    // Retry processing for a failed document
    async function retryProcessing(filename) {
      try {
        // Create a new FormData with the file
        const response = await fetch(`/documents/${encodeURIComponent(filename)}/retry`, {
          method: 'POST'
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        await loadExistingDocuments(); // Refresh the list
      } catch (error) {
        alert(`Error retrying processing: ${error.message}`);
      }
    }
    
    // Auto-refresh documents list every 5 seconds if there are documents being processed
    let autoRefreshInterval;
    
    function startAutoRefresh() {
      if (autoRefreshInterval) return; // Already running
      
      autoRefreshInterval = setInterval(async () => {
        try {
          const res = await fetch('/documents');
          const data = await res.json();
          const summary = data.processing_summary || {};
          
          // Check if there are documents still processing
          if (summary.pending > 0 || summary.processing > 0) {
            await loadExistingDocuments();
          } else {
            // Stop auto-refresh when all processing is complete
            stopAutoRefresh();
          }
        } catch (error) {
          console.error('Auto-refresh error:', error);
        }
      }, 3000); // Refresh every 3 seconds
    }
    
    function stopAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
    }

    // 2) Handle uploads with background processing
    document.getElementById('upload-form').onsubmit = async e => {
      e.preventDefault();
      const files = document.getElementById('file-input').files;
      if (!files.length) return;
      
      document.getElementById('upload-msg').innerText = 'Uploading‚Ä¶';
      
      // First, check for existing files
      const form = new FormData(e.target);
      const res = await fetch('/upload', { method: 'POST', body: form });
      const data = await res.json();
      
      // Handle results
      let message = '';
      if (data.uploaded && data.uploaded.length > 0) {
        message += `Uploaded: ${data.uploaded.join(', ')}`;
        if (data.processing && data.processing.length > 0) {
          message += ` (processing in background...)`;
        }
      }
      
      if (data.existing && data.existing.length > 0) {
        const overwrite = confirm(
          `The following files already exist:\n${data.existing.join(', ')}\n\nDo you want to overwrite them?`
        );
        
        if (overwrite) {
          // Re-upload with overwrite flag
          const overwriteForm = new FormData(e.target);
          overwriteForm.append('overwrite', 'true');
          const overwriteRes = await fetch('/upload', { method: 'POST', body: overwriteForm });
          const overwriteData = await overwriteRes.json();
          
          if (overwriteData.uploaded) {
            message += (message ? '\n' : '') + `Overwritten: ${overwriteData.uploaded.join(', ')}`;
            if (overwriteData.processing && overwriteData.processing.length > 0) {
              message += ` (processing in background...)`;
            }
          }
        } else {
          message += (message ? '\n' : '') + `Skipped existing files: ${data.existing.join(', ')}`;
        }
      }
      
      if (data.errors && data.errors.length > 0) {
        message += (message ? '\n' : '') + `Errors: ${data.errors.join(', ')}`;
      }
      
      document.getElementById('upload-msg').innerText = message || 'Upload complete!';
      await loadExistingDocuments(); // Refresh the document list
      
      // Start auto-refresh if there are documents being processed
      if ((data.processing && data.processing.length > 0) || (data.uploaded && data.uploaded.length > 0)) {
        startAutoRefresh();
      }
      
      // Clear the file input
      document.getElementById('file-input').value = '';
    };

    // 3) Handle new chat interface
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const chatMessages = document.getElementById('chat-messages');

    // Send message function
    async function sendMessage() {
      const query = chatInput.value.trim();
      if (!query) return;

      // Add user message to chat
      addMessageToChat('user', query);
      
      // Clear input and disable send button
      chatInput.value = '';
      sendBtn.disabled = true;
      
      // Add thinking message
      const thinkingId = addMessageToChat('ai', 'Thinking... (this may take a while)', true);
      
      try {
        const res = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ query })
        });
        
        if (!res.ok) {
          const errorText = await res.text();
          let errorMessage;
          try {
            const errorJson = JSON.parse(errorText);
            errorMessage = errorJson.detail || 'Unknown error';
          } catch {
            errorMessage = errorText || `HTTP ${res.status}`;
          }
          throw new Error(errorMessage);
        }
        
        const data = await res.json();
        
        // Replace thinking message with actual response
        const thinkingMsg = document.getElementById(thinkingId);
        if (thinkingMsg) {
          thinkingMsg.querySelector('.message-content').textContent = data.response || 'No response received';
        }
        
      } catch (error) {
        // Replace thinking message with error
        const thinkingMsg = document.getElementById(thinkingId);
        if (thinkingMsg) {
          thinkingMsg.querySelector('.message-content').textContent = `Error: ${error.message}`;
          thinkingMsg.querySelector('.message-content').style.color = 'var(--danger-color)';
        }
        console.error('Chat error:', error);
      } finally {
        sendBtn.disabled = false;
        chatInput.focus();
      }
    }

    // Add message to chat function
    function addMessageToChat(sender, content, isTemporary = false) {
      const messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const messageDiv = document.createElement('div');
      messageDiv.className = `message message-${sender}`;
      messageDiv.id = messageId;
      
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
      `;
      
      // Remove welcome message if it exists
      const welcomeMsg = chatMessages.querySelector('.welcome-message');
      if (welcomeMsg) {
        welcomeMsg.remove();
      }
      
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      return messageId;
    }

    // Send button click handler
    sendBtn.addEventListener('click', sendMessage);

    // Textarea key handlers
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
      // Shift+Enter adds new line (default behavior when we don't prevent it)
    });

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    // Helper function to group models by family
    function groupModelsByFamily(models) {
      const families = {};
      
      models.forEach(model => {
        const baseName = model.split(':')[0];
        if (!families[baseName]) {
          families[baseName] = [];
        }
        families[baseName].push(model);
      });
      
      return families;
    }

    // Helper function to create option groups for models with memory info
    function createModelOptions(models) {
      if (!models || models.length === 0) {
        return '<option value="">-- None Available --</option>';
      }
      
      // If models are objects with memory info, group them differently
      if (typeof models[0] === 'object' && models[0].name) {
        const families = {};
        
        models.forEach(model => {
          const baseName = model.name.split(':')[0];
          if (!families[baseName]) {
            families[baseName] = [];
          }
          families[baseName].push(model);
        });
        
        let html = '';
        Object.keys(families).sort().forEach(family => {
          if (families[family].length === 1) {
            const model = families[family][0];
            const memoryInfo = `${model.estimated_ram_gb}GB - ${model.category}`;
            html += `<option value="${model.name}" title="${memoryInfo}">${model.name} (${model.estimated_ram_gb}GB)</option>`;
          } else {
            html += `<optgroup label="${family}">`;
            families[family].sort((a, b) => a.estimated_ram_gb - b.estimated_ram_gb).forEach(model => {
              const memoryInfo = `${model.estimated_ram_gb}GB - ${model.category}`;
              html += `<option value="${model.name}" title="${memoryInfo}">${model.name} (${model.estimated_ram_gb}GB)</option>`;
            });
            html += '</optgroup>';
          }
        });
        
        return html;
      } else {
        // Fallback for simple string arrays
        return models.map(m => `<option value="${m}">${m}</option>`).join('');
      }
    }

    // 4) Load remote & local models
    async function loadModels() {
      const remoteSel = document.getElementById('remote-select');
      const localSel = document.getElementById('local-select');
      document.getElementById('pull-msg').innerText = '';
      document.getElementById('run-msg').innerText = '';
      try {
        const res = await fetch('/models');
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        const data = await res.json();
        const {remote, local, remote_error} = data;
        
        // Remote models with error handling
        if (remote_error) {
          remoteSel.innerHTML = `<option>-- Error: ${remote_error} --</option>`;
          console.error('Remote models error:', remote_error);
        } else if (remote && remote.length > 0) {
          remoteSel.innerHTML = createModelOptions(remote);
        } else {
          remoteSel.innerHTML = '<option value="">-- None Available --</option>';
        }
        
        // Local models with grouping
        localSel.innerHTML = createModelOptions(local);
        
        // Always enable so user sees the state
        remoteSel.disabled = false;
        localSel.disabled = false;

        // Preselect current engine in local-select
        const engineInfoText = document.getElementById('engine-info').innerText;
        const match = engineInfoText.match(/\(Engine: ([^\s]+)/); // Match engine name before any status icons
        if (match) {
          const engineName = match[1];
          // Check if we have model objects or simple strings
          if (local && local.length > 0 && typeof local[0] === 'object') {
            const localNames = local.map(m => m.name);
            if (localNames.includes(engineName)) {
              localSel.value = engineName;
            }
          } else if (local && local.includes(engineName)) {
            localSel.value = engineName;
          }
        }
      } catch (error) {
        console.error('Error loading models:', error);
        remoteSel.innerHTML = `<option>-- Error: ${error.message} --</option>`;
        localSel.innerHTML = `<option>-- Error: ${error.message} --</option>`;
        remoteSel.disabled = false;
        localSel.disabled = false;
      }
    }

    // 5) Pull a remote model
    document.getElementById('pull-btn').addEventListener('click', async () => {
      const name = document.getElementById('remote-select').value;
      const pullMsg = document.getElementById('pull-msg');
      const btn = document.getElementById('pull-btn');
      btn.disabled = true; pullMsg.innerText = 'Pulling‚Ä¶';
      try {
        const res = await fetch('/models/pull', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error(await res.text());
        pullMsg.innerText = `Pulled ${name}`;
        await loadModels(); await checkStatus();
      } catch (e) {
        pullMsg.innerText = `Error: ${e.message}`;
      } finally {
        btn.disabled = false;
      }
    });

    // 6) Run a local model
    document.getElementById('run-btn').addEventListener('click', async () => {
      const name = document.getElementById('local-select').value;
      const runMsg = document.getElementById('run-msg');
      const btn = document.getElementById('run-btn');
      btn.disabled = true; runMsg.innerText = 'Switching‚Ä¶';
      try {
        const res = await fetch('/models/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error(await res.text());
        runMsg.innerText = `Using ${name}`;
        await checkStatus(); await loadModels();
      } catch (e) {
        runMsg.innerText = `Error: ${e.message}`;
      } finally {
        btn.disabled = false;
      }
    });

    // Initial load
    loadModels();
    loadExistingDocuments();

    // Theme switcher functionality
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = themeToggle.querySelector('.theme-icon');
    
    // Load saved theme or default to light
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateThemeIcon(savedTheme);
    
    function updateThemeIcon(theme) {
      if (theme === 'dark') {
        themeIcon.textContent = '‚òÄÔ∏è';
        themeToggle.title = 'Switch to Dawn theme (light)';
      } else {
        themeIcon.textContent = 'üåô';
        themeToggle.title = 'Switch to Moon theme (dark)';
      }
    }
    
    themeToggle.addEventListener('click', () => {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      updateThemeIcon(newTheme);
    });
  </script>
</body>
</html>
