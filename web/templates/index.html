<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Documents Chat AI</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="app-container">
    <!-- Left Sidebar -->
    <aside class="sidebar">
      <header class="sidebar-header">
        <div class="header-content">
          <h1>Documents Chat AI</h1>
          <button id="theme-toggle" class="theme-toggle" title="Switch between Dawn and Moon themes">
            <span class="theme-icon">üåô</span>
          </button>
        </div>
      </header>
      
      <!-- Documents Management -->
      <section class="documents-section">
        <h3>Documents</h3>
        
        <!-- Project Management -->
        <div class="project-management">
          <div class="project-header">
            <label for="project-select">Project:</label>
            <select id="project-select" class="project-select">
              <option value="global">Global Documents</option>
            </select>
            <button id="new-project-btn" class="btn-small" title="Create new project">+</button>
            <button id="delete-project-btn" class="btn-small btn-danger" title="Delete current project">üóëÔ∏è</button>
          </div>
          
          <!-- New Project Modal -->
          <div id="new-project-modal" class="modal" style="display: none;">
            <div class="modal-content">
              <h4>Create New Project</h4>
              <input type="text" id="new-project-name" placeholder="Project name" maxlength="50">
              <div class="modal-buttons">
                <button id="create-project-btn" class="btn-primary">Create</button>
                <button id="cancel-project-btn" class="btn-secondary">Cancel</button>
              </div>
              <div id="project-msg" class="status-msg"></div>
            </div>
          </div>
        </div>
        
        <div id="existing-docs">
          <div id="docs-list">Loading documents...</div>
        </div>
        <div class="upload-area">
          <form id="upload-form" action="/upload" method="post" enctype="multipart/form-data">
            <input type="file"
                   name="files"
                   id="file-input"
                   multiple
                   accept=".pdf,.docx,.doc,.txt,.md"
                   class="file-input">
            <input type="hidden" name="project" id="upload-project" value="global">
            <button type="submit" class="btn-primary">Upload Files</button>
          </form>
          <div id="upload-msg" class="status-msg"></div>
        </div>
      </section>

      <!-- Models Management -->
      <section class="models-section">
        <h3>Models</h3>
        <div class="model-group">
          <label for="remote-select">Available Models:</label>
          <select id="remote-select"></select>
          <button id="pull-btn" class="btn-secondary">Download</button>
          <span id="pull-msg" class="status-msg"></span>
        </div>
        <div class="model-group">
          <label for="local-select">Active Model:</label>
          <select id="local-select"></select>
          <button id="run-btn" class="btn-primary">Use</button>
          <span id="run-msg" class="status-msg"></span>
        </div>
      </section>

      <!-- System Status -->
      <section class="status-section">
        <h3>System Status</h3>
        <div id="status">
          <div class="status-item">
            <span class="status-label">Ollama:</span>
            <span id="conn-status">Checking‚Ä¶</span>
          </div>
          <div class="status-item">
            <span class="status-label">Engine:</span>
            <span id="engine-info">Loading‚Ä¶</span>
          </div>
          <div class="status-item">
            <span class="status-label">Memory:</span>
            <span id="memory-info">Checking‚Ä¶</span>
          </div>
        </div>
      </section>
    </aside>

    <!-- Main Chat Area -->
    <main class="chat-container">
      <div class="chat-messages" id="chat-messages">
        <div class="welcome-message">
          <h2>ü§ñ Welcome to Documents Chat AI</h2>
          <p>Your intelligent document assistant powered by Ollama</p>
          <div class="welcome-features">
            <div class="feature-grid">
              <div class="feature-item">
                <span class="feature-icon">üìÅ</span>
                <span>Upload PDFs, DOCX, TXT files</span>
              </div>
              <div class="feature-item">
                <span class="feature-icon">üîç</span>
                <span>Advanced OCR for scanned documents</span>
              </div>
              <div class="feature-item">
                <span class="feature-icon">üß†</span>
                <span>Intelligent document analysis</span>
              </div>
              <div class="feature-item">
                <span class="feature-icon">üí¨</span>
                <span>Context-aware AI responses</span>
              </div>
            </div>
          </div>
          <div class="welcome-actions">
            <p><strong>Get started:</strong></p>
            <ol>
              <li>Upload documents using the sidebar</li>
              <li>Ask questions about your documents</li>
              <li>Or just chat with the AI without documents!</li>
            </ol>
            <div class="theme-info">
              <p>üí° <em>Try switching between Ros√© Pine Dawn ‚òÄÔ∏è and Moon üåô themes using the button above!</em></p>
            </div>
          </div>
        </div>
      </div>
      
      <div class="chat-input-area">
        <div class="input-container">
          <textarea id="chat-input" 
                    placeholder="Ask a question about your documents... (Enter to send, Shift+Enter for new line)"
                    rows="3"></textarea>
          <button id="send-btn" class="btn-send" title="Send message (Enter)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="22" y1="2" x2="11" y2="13"></line>
              <polygon points="22,2 15,22 11,13 2,9"></polygon>
            </svg>
          </button>
        </div>
        <div class="input-help">
          <small>Press <kbd>Enter</kbd> to send, <kbd>Shift+Enter</kbd> for new line</small>
        </div>
      </div>
    </main>
  </div>

  <script>
    // 1) Check Ollama status
    async function checkStatus() {
      try {
        const res = await fetch('/status');
        const {connected, engine} = await res.json();
        document.getElementById('conn-status').innerText =
          connected ? 'üü¢ Ollama online' : 'üî¥ Ollama offline';
        
        // Handle engine object properly
        let engineText = '';
        if (connected && engine && engine.name) {
          let status = '';
          if (engine.verified) {
            status = '‚úÖ';
          } else if (engine.available) {
            status = '‚è≥';
          } else {
            status = '‚ùå';
          }
          engineText = `(Engine: ${engine.name} ${status})`;
        }
        document.getElementById('engine-info').innerText = engineText;
      } catch {
        document.getElementById('conn-status').innerText = 'üî¥ Error';
      }
    }
    checkStatus();
    setInterval(checkStatus, 15000);

    // Check system memory
    async function checkMemory() {
      try {
        const res = await fetch('/system/memory');
        const memory = await res.json();
        const memoryText = `üíæ RAM: ${memory.used_gb}/${memory.total_gb}GB (${memory.percent_used.toFixed(1)}%)`;
        document.getElementById('memory-info').innerText = memoryText;
      } catch {
        document.getElementById('memory-info').innerText = 'üíæ Memory: Error';
      }
    }
    checkMemory();
    setInterval(checkMemory, 30000);

    // Load and display existing documents with processing status
    async function loadExistingDocuments() {
      try {
        const res = await fetch('/documents');
        const data = await res.json();
        const docsList = document.getElementById('docs-list');
        
        if (data.documents && data.documents.length > 0) {
          let html = '';
          
          // Filter documents by current project
          const filteredDocs = data.documents.filter(doc => {
            if (currentProject === 'global') {
              // Show global documents (no slash in filename)
              return !doc.includes('/');
            } else {
              // Show documents belonging to current project
              return doc.startsWith(currentProject + '/');
            }
          });
          
          if (filteredDocs.length === 0) {
            docsList.innerHTML = '<em>No documents in this project</em>';
            return;
          }
          
          filteredDocs.forEach(doc => {
            const info = data.document_info[doc] || {};
            const status = info.processing_status || 'completed';
            const progress = info.processing_progress || 100;
            const isProcessed = info.is_processed || false;
            const chunks = info.total_chunks || 0;
            const chars = info.total_chars || 0;
            const error = info.error;
            
            // Display name without project prefix
            const displayName = currentProject === 'global' ? doc : doc.substring(currentProject.length + 1);
            
            // Status icon and text
            let statusIcon = '';
            let statusText = '';
            let statusClass = '';
            
            switch (status) {
              case 'pending':
                statusIcon = '‚è≥';
                statusText = 'Waiting to process...';
                statusClass = 'status-pending';
                break;
              case 'processing':
                statusIcon = 'üîÑ';
                statusText = `Processing... ${progress}%`;
                statusClass = 'status-processing';
                break;
              case 'completed':
                statusIcon = '‚úÖ';
                statusText = isProcessed ? `${chunks} chunks, ${(chars/1000).toFixed(1)}k chars` : 'Uploaded';
                statusClass = 'status-completed';
                break;
              case 'error':
                statusIcon = '‚ùå';
                statusText = `Error: ${error || 'Processing failed'}`;
                statusClass = 'status-error';
                break;
            }
            
            html += `
              <div class="doc-item ${statusClass}">
                <div class="doc-header">
                  <span class="doc-name" title="${displayName}">${displayName.length > 25 ? displayName.substring(0, 25) + '...' : displayName}</span>
                  <span class="status-icon">${statusIcon}</span>
                </div>
                <div class="doc-info">
                  <span class="status-text">${statusText}</span>
                  ${status === 'processing' ? `<div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>` : ''}
                </div>
                <div class="doc-actions">
                  ${isProcessed ? `<button class="btn-xs" onclick="viewDocumentChunks('${doc}')" title="View Chunks">üìä</button>` : ''}
                  <button class="btn-xs delete" onclick="deleteDocument('${doc}')" title="Delete">üóëÔ∏è</button>
                  ${status === 'error' ? `<button class="btn-xs retry" onclick="retryProcessing('${doc}')" title="Retry">üîÑ</button>` : ''}
                </div>
              </div>`;
          });
          
          // Summary with processing info for current project
          const summary = data.processing_summary || {};
          const totalChunksInProject = filteredDocs.reduce((sum, doc) => {
            const info = data.document_info[doc] || {};
            return sum + (info.total_chunks || 0);
          }, 0);
          
          let summaryText = `${filteredDocs.length} documents, ${totalChunksInProject} chunks`;
          const pendingInProject = filteredDocs.filter(doc => data.document_info[doc]?.processing_status === 'pending').length;
          const processingInProject = filteredDocs.filter(doc => data.document_info[doc]?.processing_status === 'processing').length;
          
          if (processingInProject > 0 || pendingInProject > 0) {
            summaryText += ` (${pendingInProject} pending, ${processingInProject} processing)`;
          }
          
          html += `<div class="doc-summary">${summaryText}</div>`;
          docsList.innerHTML = html;
        } else {
          docsList.innerHTML = '<em>No documents uploaded yet</em>';
        }
      } catch (error) {
        document.getElementById('docs-list').innerHTML = '<em>Error loading documents</em>';
        console.error('Error loading documents:', error);
      }
    }

    // View chunks for a specific document
    async function viewDocumentChunks(filename) {
      try {
        const res = await fetch(`/documents/${encodeURIComponent(filename)}/chunks`);
        const data = await res.json();
        
        let html = `
          <div class="chunks-header">
            <h4>Chunks for "${filename}"</h4>
            <div class="chunks-header-actions">
              <button class="btn-secondary" onclick="copyAllChunks('${filename}', ${JSON.stringify(data.chunks)})" title="Copy all chunks">üìã Copy All</button>
            </div>
          </div>`;
        html += `<p>Total chunks: ${data.total_chunks}</p>`;
        html += `
          <div class="chunk-search">
            <input type="text" id="chunk-search-input" placeholder="Search in chunks..." class="search-input">
            <button onclick="clearChunkSearch()" class="btn-xs">Clear</button>
            <div class="search-navigation" style="display: none;">
              <button onclick="navigateSearchResults(-1)" class="btn-xs" title="Previous result">‚Üë</button>
              <span id="search-results-info"></span>
              <button onclick="navigateSearchResults(1)" class="btn-xs" title="Next result">‚Üì</button>
            </div>
          </div>`;
        
        data.chunks.forEach((chunk, index) => {
          const isExpanded = chunk.preview === chunk.full_content; // Check if content is already fully shown
          html += `
            <div class="chunk-item">
              <div class="chunk-header">
                <strong>Chunk ${chunk.chunk_index}/${data.total_chunks}</strong>
                <div class="chunk-actions">
                  <span class="chunk-size">(${chunk.char_count} characters)</span>
                  <button class="btn-xs copy-chunk" onclick="copyChunkContent(this, ${index})" data-chunk-index="${index}" title="Copy chunk content">üìã</button>
                  ${!isExpanded ? `<button class="btn-xs expand-chunk" onclick="toggleChunkContent(this, ${index})" data-chunk-index="${index}" title="Show full content">üìñ Expand</button>` : ''}
                </div>
              </div>
              <div class="chunk-preview" data-preview="${chunk.preview.replace(/"/g, '&quot;')}" data-full="${chunk.full_content ? chunk.full_content.replace(/"/g, '&quot;') : ''}">${chunk.preview}</div>
            </div>`;
        });
        
        // Create modal or update a section to show chunks
        const modal = document.createElement('div');
        modal.className = 'chunks-modal';
        modal.innerHTML = `
          <div class="chunks-modal-content">
            <span class="chunks-modal-close" onclick="this.parentElement.parentElement.remove()">&times;</span>
            ${html}
          </div>`;
        
        // Add ESC key listener to close modal
        const handleEscKey = (event) => {
          if (event.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', handleEscKey);
          }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // Add click outside to close modal
        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            modal.remove();
            document.removeEventListener('keydown', handleEscKey);
          }
        });
        
        document.body.appendChild(modal);
        
        // Add search functionality
        const searchInput = document.getElementById('chunk-search-input');
        if (searchInput) {
          searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase().trim();
            const chunkItems = modal.querySelectorAll('.chunk-item');
            
            chunkItems.forEach(item => {
              const chunkPreview = item.querySelector('.chunk-preview');
              const content = chunkPreview.textContent.toLowerCase();
              const chunkHeader = item.querySelector('.chunk-header strong').textContent.toLowerCase();
              
              // Reset highlight
              const originalContent = chunkPreview.getAttribute('data-original') || chunkPreview.innerHTML;
              if (!chunkPreview.getAttribute('data-original')) {
                chunkPreview.setAttribute('data-original', chunkPreview.innerHTML);
              }
              
              if (content.includes(searchTerm) || chunkHeader.includes(searchTerm) || searchTerm === '') {
                item.style.display = 'block';
                
                // Highlight search term
                if (searchTerm && searchTerm.length > 0) {
                  const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                  const highlightedContent = originalContent.replace(regex, '<mark class="search-highlight">$1</mark>');
                  chunkPreview.innerHTML = highlightedContent;
                } else {
                  chunkPreview.innerHTML = originalContent;
                }
              } else {
                item.style.display = 'none';
              }
            });
          });
        }
        
      } catch (error) {
        alert(`Error loading chunks: ${error.message}`);
      }
    }

    // Toggle chunk content between preview and full content
    function toggleChunkContent(button, chunkIndex) {
      const chunkPreview = button.parentElement.nextElementSibling;
      const previewText = chunkPreview.getAttribute('data-preview');
      const fullText = chunkPreview.getAttribute('data-full');
      
      if (button.textContent.includes('Expand')) {
        // Show full content
        chunkPreview.innerHTML = fullText || previewText;
        button.innerHTML = 'üìÑ Collapse';
        button.title = 'Show preview only';
      } else {
        // Show preview
        chunkPreview.innerHTML = previewText;
        button.innerHTML = 'üìñ Expand';
        button.title = 'Show full content';
      }
    }

    // Clear chunk search
    function clearChunkSearch() {
      const searchInput = document.getElementById('chunk-search-input');
      const modal = document.querySelector('.chunks-modal');
      
      if (searchInput) {
        searchInput.value = '';
        
        // Show all chunks and remove highlights
        if (modal) {
          const chunkItems = modal.querySelectorAll('.chunk-item');
          chunkItems.forEach(item => {
            item.style.display = 'block';
            
            // Remove highlights
            const chunkPreview = item.querySelector('.chunk-preview');
            const originalContent = chunkPreview.getAttribute('data-original');
            if (originalContent) {
              chunkPreview.innerHTML = originalContent;
            }
          });
          
          // Hide search navigation
          const searchNav = modal.querySelector('.search-navigation');
          if (searchNav) {
            searchNav.style.display = 'none';
          }
        }
      }
    }

    // Copy chunk content to clipboard
    function copyChunkContent(button, chunkIndex) {
      const chunkPreview = button.closest('.chunk-item').querySelector('.chunk-preview');
      const content = chunkPreview.textContent || chunkPreview.innerText;
      
      navigator.clipboard.writeText(content).then(() => {
        const originalText = button.innerHTML;
        button.innerHTML = '‚úÖ';
        button.title = 'Copied!';
        setTimeout(() => {
          button.innerHTML = originalText;
          button.title = 'Copy chunk content';
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy text: ', err);
        // Fallback for browsers that don't support clipboard API
        const textArea = document.createElement('textarea');
        textArea.value = content;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          const originalText = button.innerHTML;
          button.innerHTML = '‚úÖ';
          button.title = 'Copied!';
          setTimeout(() => {
            button.innerHTML = originalText;
            button.title = 'Copy chunk content';
          }, 2000);
        } catch (err) {
          alert('Copy failed. Please manually select and copy the text.');
        }
        document.body.removeChild(textArea);
      });
    }

    // Copy all chunks content to clipboard
    function copyAllChunks(filename, chunks) {
      const allContent = chunks.map((chunk, index) => 
        `=== Chunk ${chunk.chunk_index}/${chunks.length} ===\n${chunk.full_content || chunk.preview}\n`
      ).join('\n');
      
      const fullContent = `Document: ${filename}\nTotal Chunks: ${chunks.length}\n\n${allContent}`;
      
      navigator.clipboard.writeText(fullContent).then(() => {
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '‚úÖ Copied All';
        setTimeout(() => {
          button.innerHTML = originalText;
        }, 3000);
      }).catch(err => {
        console.error('Failed to copy all chunks: ', err);
        alert('Copy failed. Please try copying individual chunks.');
      });
    }

    // Delete a document
    async function deleteDocument(filename) {
      if (!confirm(`Are you sure you want to delete "${filename}"?`)) {
        return;
      }
      
      try {
        const res = await fetch(`/documents/${encodeURIComponent(filename)}`, {
          method: 'DELETE'
        });
        
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        await loadProjects(); // Refresh projects to update document counts
        await loadExistingDocuments(); // Refresh the list
        document.getElementById('upload-msg').innerText = `Deleted "${filename}"`;
        setTimeout(() => {
          document.getElementById('upload-msg').innerText = '';
        }, 3000);
      } catch (error) {
        alert(`Error deleting document: ${error.message}`);
      }
    }

    // Retry processing for a failed document
    async function retryProcessing(filename) {
      try {
        // Create a new FormData with the file
        const response = await fetch(`/documents/${encodeURIComponent(filename)}/retry`, {
          method: 'POST'
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        await loadExistingDocuments(); // Refresh the list
      } catch (error) {
        alert(`Error retrying processing: ${error.message}`);
      }
    }
    
    // Auto-refresh documents list every 5 seconds if there are documents being processed
    let autoRefreshInterval;
    
    function startAutoRefresh() {
      if (autoRefreshInterval) return; // Already running
      
      autoRefreshInterval = setInterval(async () => {
        try {
          const res = await fetch('/documents');
          const data = await res.json();
          const summary = data.processing_summary || {};
          
          // Check if there are documents still processing
          if (summary.pending > 0 || summary.processing > 0) {
            await loadExistingDocuments();
          } else {
            // Stop auto-refresh when all processing is complete
            stopAutoRefresh();
          }
        } catch (error) {
          console.error('Auto-refresh error:', error);
        }
      }, 3000); // Refresh every 3 seconds
    }
    
    function stopAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
    }

    // Project Management Functions
    let currentProject = 'global';
    
    async function loadProjects() {
      try {
        const res = await fetch('/projects');
        const data = await res.json();
        const projectSelect = document.getElementById('project-select');
        
        projectSelect.innerHTML = '';
        data.projects.forEach(project => {
          const option = document.createElement('option');
          option.value = project.name;
          option.textContent = project.is_global ? 'Global Documents' : project.name;
          if (project.document_count > 0) {
            option.textContent += ` (${project.document_count})`;
          }
          projectSelect.appendChild(option);
        });
        
        // Set current project
        projectSelect.value = currentProject;
        document.getElementById('upload-project').value = currentProject;
        
        // Update delete button state
        const deleteBtn = document.getElementById('delete-project-btn');
        deleteBtn.style.display = currentProject === 'global' ? 'none' : 'inline-flex';
        
      } catch (error) {
        console.error('Error loading projects:', error);
      }
    }
    
    async function createProject() {
      const name = document.getElementById('new-project-name').value.trim();
      if (!name) {
        document.getElementById('project-msg').textContent = 'Please enter a project name';
        return;
      }
      
      if (!/^[a-zA-Z0-9_-]+$/.test(name)) {
        document.getElementById('project-msg').textContent = 'Use only letters, numbers, underscore and dash';
        return;
      }
      
      try {
        const res = await fetch('/projects', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({name: name})
        });
        
        if (res.ok) {
          document.getElementById('new-project-modal').style.display = 'none';
          document.getElementById('new-project-name').value = '';
          document.getElementById('project-msg').textContent = '';
          currentProject = name;
          await loadProjects();
          await loadExistingDocuments();
        } else {
          const error = await res.json();
          document.getElementById('project-msg').textContent = error.detail || 'Error creating project';
        }
      } catch (error) {
        document.getElementById('project-msg').textContent = 'Error creating project';
        console.error('Error creating project:', error);
      }
    }
    
    async function deleteCurrentProject() {
      if (currentProject === 'global') return;
      
      if (!confirm(`Are you sure you want to delete project "${currentProject}"? This will delete all documents in the project.`)) {
        return;
      }
      
      try {
        const res = await fetch(`/projects/${encodeURIComponent(currentProject)}?force=true`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          currentProject = 'global';
          await loadProjects();
          await loadExistingDocuments();
        } else {
          const error = await res.json();
          alert(error.detail || 'Error deleting project');
        }
      } catch (error) {
        alert('Error deleting project');
        console.error('Error deleting project:', error);
      }
    }
    
    // Event listeners for project management
    document.getElementById('project-select').addEventListener('change', async function() {
      currentProject = this.value;
      document.getElementById('upload-project').value = currentProject;
      
      // Update delete button state
      const deleteBtn = document.getElementById('delete-project-btn');
      deleteBtn.style.display = currentProject === 'global' ? 'none' : 'inline-flex';
      
      await loadExistingDocuments();
    });
    
    document.getElementById('new-project-btn').addEventListener('click', function() {
      document.getElementById('new-project-modal').style.display = 'flex';
      document.getElementById('new-project-name').focus();
    });
    
    document.getElementById('cancel-project-btn').addEventListener('click', function() {
      document.getElementById('new-project-modal').style.display = 'none';
      document.getElementById('new-project-name').value = '';
      document.getElementById('project-msg').textContent = '';
    });
    
    document.getElementById('create-project-btn').addEventListener('click', createProject);
    
    document.getElementById('new-project-name').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        createProject();
      }
    });
    
    document.getElementById('delete-project-btn').addEventListener('click', deleteCurrentProject);
    
    // Close modal when clicking outside
    document.getElementById('new-project-modal').addEventListener('click', function(e) {
      if (e.target === this) {
        this.style.display = 'none';
        document.getElementById('new-project-name').value = '';
        document.getElementById('project-msg').textContent = '';
      }
    });

    // 2) Handle uploads with background processing
    document.getElementById('upload-form').onsubmit = async e => {
      e.preventDefault();
      const files = document.getElementById('file-input').files;
      if (!files.length) return;
      
      document.getElementById('upload-msg').innerText = 'Uploading‚Ä¶';
      
      // First, check for existing files
      const form = new FormData(e.target);
      const res = await fetch('/upload', { method: 'POST', body: form });
      const data = await res.json();
      
      // Handle results
      let message = '';
      if (data.uploaded && data.uploaded.length > 0) {
        message += `Uploaded: ${data.uploaded.join(', ')}`;
        if (data.processing && data.processing.length > 0) {
          message += ` (processing in background...)`;
        }
      }
      
      if (data.existing && data.existing.length > 0) {
        const overwrite = confirm(
          `The following files already exist:\n${data.existing.join(', ')}\n\nDo you want to overwrite them?`
        );
        
        if (overwrite) {
          // Re-upload with overwrite flag
          const overwriteForm = new FormData(e.target);
          overwriteForm.append('overwrite', 'true');
          const overwriteRes = await fetch('/upload', { method: 'POST', body: overwriteForm });
          const overwriteData = await overwriteRes.json();
          
          if (overwriteData.uploaded) {
            message += (message ? '\n' : '') + `Overwritten: ${overwriteData.uploaded.join(', ')}`;
            if (overwriteData.processing && overwriteData.processing.length > 0) {
              message += ` (processing in background...)`;
            }
          }
        } else {
          message += (message ? '\n' : '') + `Skipped existing files: ${data.existing.join(', ')}`;
        }
      }
      
      if (data.errors && data.errors.length > 0) {
        message += (message ? '\n' : '') + `Errors: ${data.errors.join(', ')}`;
      }
      
      document.getElementById('upload-msg').innerText = message || 'Upload complete!';
      await loadProjects(); // Refresh projects to update document counts
      await loadExistingDocuments(); // Refresh the document list
      
      // Start auto-refresh if there are documents being processed
      if ((data.processing && data.processing.length > 0) || (data.uploaded && data.uploaded.length > 0)) {
        startAutoRefresh();
      }
      
      // Clear the file input
      document.getElementById('file-input').value = '';
    };

    // 3) Handle new chat interface
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const chatMessages = document.getElementById('chat-messages');

    // Send message function
    async function sendMessage() {
      const query = chatInput.value.trim();
      if (!query) return;

      // Add user message to chat
      addMessageToChat('user', query);
      
      // Clear input and disable send button
      chatInput.value = '';
      sendBtn.disabled = true;
      
      // Add thinking message
      const thinkingId = addMessageToChat('ai', 'Thinking... (this may take a while)', true);
      
      try {
        // Include current project in the request
        const formData = new URLSearchParams({ 
          query: query,
          project: currentProject
        });
        
        const res = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: formData
        });
        
        if (!res.ok) {
          const errorText = await res.text();
          let errorMessage;
          try {
            const errorJson = JSON.parse(errorText);
            errorMessage = errorJson.detail || 'Unknown error';
          } catch {
            errorMessage = errorText || `HTTP ${res.status}`;
          }
          throw new Error(errorMessage);
        }
        
        const data = await res.json();
        
        // Replace thinking message with actual response
        const thinkingMsg = document.getElementById(thinkingId);
        if (thinkingMsg) {
          thinkingMsg.querySelector('.message-content').textContent = data.response || 'No response received';
        }
        
      } catch (error) {
        // Replace thinking message with error
        const thinkingMsg = document.getElementById(thinkingId);
        if (thinkingMsg) {
          thinkingMsg.querySelector('.message-content').textContent = `Error: ${error.message}`;
          thinkingMsg.querySelector('.message-content').style.color = 'var(--danger-color)';
        }
        console.error('Chat error:', error);
      } finally {
        sendBtn.disabled = false;
        chatInput.focus();
      }
    }

    // Add message to chat function
    function addMessageToChat(sender, content, isTemporary = false) {
      const messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const messageDiv = document.createElement('div');
      messageDiv.id = messageId;
      messageDiv.className = `message ${sender}-message`;
      
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-timestamp">${new Date().toLocaleTimeString()}</div>
      `;
      
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      return messageId;
    }

    // Send button click handler
    sendBtn.addEventListener('click', sendMessage);

    // Textarea key handlers
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
      // Shift+Enter adds new line (default behavior when we don't prevent it)
    });

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    // Helper function to group models by family
    function groupModelsByFamily(models) {
      const families = {};
      
      models.forEach(model => {
        const baseName = model.split(':')[0];
        if (!families[baseName]) {
          families[baseName] = [];
        }
        families[baseName].push(model);
      });
      
      return families;
    }

    // Helper function to create option groups for models with memory info
    function createModelOptions(models) {
      if (!models || models.length === 0) {
        return '<option value="">-- None Available --</option>';
      }
      
      // If models are objects with memory info, group them differently
      if (typeof models[0] === 'object' && models[0].name) {
        const families = {};
        
        models.forEach(model => {
          const baseName = model.name.split(':')[0];
          if (!families[baseName]) {
            families[baseName] = [];
          }
          families[baseName].push(model);
        });
        
        let html = '';
        Object.keys(families).sort().forEach(family => {
          if (families[family].length === 1) {
            const model = families[family][0];
            const memoryInfo = `${model.estimated_ram_gb}GB - ${model.category}`;
            html += `<option value="${model.name}" title="${memoryInfo}">${model.name} (${model.estimated_ram_gb}GB)</option>`;
          } else {
            html += `<optgroup label="${family}">`;
            families[family].sort((a, b) => a.estimated_ram_gb - b.estimated_ram_gb).forEach(model => {
              const memoryInfo = `${model.estimated_ram_gb}GB - ${model.category}`;
              html += `<option value="${model.name}" title="${memoryInfo}">${model.name} (${model.estimated_ram_gb}GB)</option>`;
            });
            html += '</optgroup>';
          }
        });
        
        return html;
      } else {
        // Fallback for simple string arrays
        return models.map(m => `<option value="${m}">${m}</option>`).join('');
      }
    }

    // 4) Load remote & local models
    async function loadModels() {
      const remoteSel = document.getElementById('remote-select');
      const localSel = document.getElementById('local-select');
      document.getElementById('pull-msg').innerText = '';
      document.getElementById('run-msg').innerText = '';
      try {
        const res = await fetch('/models');
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        const data = await res.json();
        const {remote, local, remote_error} = data;
        
        // Remote models with error handling
        if (remote_error) {
          remoteSel.innerHTML = `<option>-- Error: ${remote_error} --</option>`;
          console.error('Remote models error:', remote_error);
        } else if (remote && remote.length > 0) {
          remoteSel.innerHTML = createModelOptions(remote);
        } else {
          remoteSel.innerHTML = '<option value="">-- None Available --</option>';
        }
        
        // Local models with grouping
        localSel.innerHTML = createModelOptions(local);
        
        // Always enable so user sees the state
        remoteSel.disabled = false;
        localSel.disabled = false;

        // Preselect current engine in local-select
        const engineInfoText = document.getElementById('engine-info').innerText;
        const match = engineInfoText.match(/\(Engine: ([^\s]+)/); // Match engine name before any status icons
        if (match) {
          const engineName = match[1];
          // Check if we have model objects or simple strings
          if (local && local.length > 0 && typeof local[0] === 'object') {
            const localNames = local.map(m => m.name);
            if (localNames.includes(engineName)) {
              localSel.value = engineName;
            }
          } else if (local && local.includes(engineName)) {
            localSel.value = engineName;
          }
        }
      } catch (error) {
        console.error('Error loading models:', error);
        remoteSel.innerHTML = `<option>-- Error: ${error.message} --</option>`;
        localSel.innerHTML = `<option>-- Error: ${error.message} --</option>`;
        remoteSel.disabled = false;
        localSel.disabled = false;
      }
    }

    // 5) Pull a remote model
    document.getElementById('pull-btn').addEventListener('click', async () => {
      const name = document.getElementById('remote-select').value;
      const pullMsg = document.getElementById('pull-msg');
      const btn = document.getElementById('pull-btn');
      btn.disabled = true; pullMsg.innerText = 'Pulling‚Ä¶';
      try {
        const res = await fetch('/models/pull', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error(await res.text());
        pullMsg.innerText = `Pulled ${name}`;
        await loadModels(); await checkStatus();
      } catch (e) {
        pullMsg.innerText = `Error: ${e.message}`;
      } finally {
        btn.disabled = false;
      }
    });

    // 6) Run a local model
    document.getElementById('run-btn').addEventListener('click', async () => {
      const name = document.getElementById('local-select').value;
      const runMsg = document.getElementById('run-msg');
      const btn = document.getElementById('run-btn');
      btn.disabled = true; runMsg.innerText = 'Switching‚Ä¶';
      try {
        const res = await fetch('/models/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error(await res.text());
        runMsg.innerText = `Using ${name}`;
        await checkStatus(); await loadModels();
      } catch (e) {
        runMsg.innerText = `Error: ${e.message}`;
      } finally {
        btn.disabled = false;
      }
    });

    // Initial load
    loadModels();
    loadProjects().then(() => loadExistingDocuments());

    // Theme switcher functionality
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = themeToggle.querySelector('.theme-icon');
    
    // Load saved theme or default to light
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateThemeIcon(savedTheme);
    
    function updateThemeIcon(theme) {
      if (theme === 'dark') {
        themeIcon.textContent = '‚òÄÔ∏è';
        themeToggle.title = 'Switch to Dawn theme (light)';
      } else {
        themeIcon.textContent = 'üåô';
        themeToggle.title = 'Switch to Moon theme (dark)';
      }
    }
    
    themeToggle.addEventListener('click', () => {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      updateThemeIcon(newTheme);
    });
  </script>
</body>
</html>